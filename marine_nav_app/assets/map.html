<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>SailStream Map</title>
    <link
      rel="stylesheet"
      href="https://unpkg.com/maplibre-gl@4.1.2/dist/maplibre-gl.css"
    />
    <script src="https://unpkg.com/maplibre-gl@4.1.2/dist/maplibre-gl.js"></script>
    <style>
      html, body, #map {
        height: 100%;
        margin: 0;
        padding: 0;
        background: #0a1f3f;
      }
      #loading {
        position: absolute;
        inset: 0;
        display: flex;
        align-items: center;
        justify-content: center;
        flex-direction: column;
        gap: 8px;
        color: #ffffff;
        font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', sans-serif;
        z-index: 10;
        background: #0a1f3f;
        transition: opacity 0.3s ease;
      }
      #loading.hidden { opacity: 0; pointer-events: none; }
      .badge {
        padding: 6px 12px;
        border-radius: 999px;
        background: rgba(0, 201, 167, 0.2);
        color: #00c9a7;
        border: 1px solid rgba(0, 201, 167, 0.5);
        font-size: 12px;
      }
    </style>
  </head>
  <body>
    <div id="map"></div>
    <div id="loading">
      <div class="badge">Loading MapTiler…</div>
    </div>

    <script>
      // Bridge for Dart ↔ JS communication
      window.mapBridge = {
        _map: null,
        _suppressEvents: false,
        _apiKey: null,

        // Called from Dart to set the MapTiler API key and initialize
        setApiKey: function (key) {
          this._apiKey = key;
          this._initMap();
        },

        // Initialize MapLibre GL map
        _initMap: function () {
          if (!this._apiKey || this._map) return;

          try {
            this._map = new maplibregl.Map({
              container: 'map',
              style:
                'https://api.maptiler.com/maps/ocean/style.json?key=' +
                this._apiKey,
              center: [0, 0],
              zoom: 3,
              attributionControl: false,
            });

            this._map.addControl(
              new maplibregl.AttributionControl({ compact: true }),
              'bottom-right'
            );

            this._map.on('load', function () {
              document.getElementById('loading').classList.add('hidden');
              window.mapBridge._sendToDart({
                type: 'mapReady',
              });
            });

            this._map.on('moveend', function () {
              window.mapBridge._emitViewport();
            });

            this._map.on('zoomend', function () {
              window.mapBridge._emitViewport();
            });

            this._map.on('rotateend', function () {
              window.mapBridge._emitViewport();
            });

            this._map.on('error', function (e) {
              window.mapBridge._sendToDart({
                type: 'error',
                message: e.error ? e.error.message : 'Map error',
              });
            });
          } catch (e) {
            this._sendToDart({
              type: 'error',
              message: 'Map init failed: ' + e.message,
            });
          }
        },

        // Emit current viewport state to Dart
        _emitViewport: function () {
          if (this._suppressEvents || !this._map) return;
          var center = this._map.getCenter();
          this._sendToDart({
            type: 'viewportChanged',
            center: [center.lat, center.lng],
            zoom: this._map.getZoom(),
            rotation: (-this._map.getBearing() * Math.PI) / 180,
          });
        },

        // Send JSON message to Dart via MapBridge channel
        _sendToDart: function (obj) {
          try {
            if (window.MapBridge) {
              window.MapBridge.postMessage(JSON.stringify(obj));
            }
          } catch (e) {
            console.error('MapBridge send failed:', e);
          }
        },

        // Called from Dart to update map center
        setCenter: function (lat, lng) {
          if (!this._map) return;
          this._suppressEvents = true;
          this._map.setCenter([lng, lat]);
          this._suppressEvents = false;
        },

        // Called from Dart to update zoom level
        setZoom: function (zoom) {
          if (!this._map) return;
          this._suppressEvents = true;
          this._map.setZoom(zoom);
          this._suppressEvents = false;
        },

        // Called from Dart to update rotation (radians → degrees)
        setRotation: function (radians) {
          if (!this._map) return;
          this._suppressEvents = true;
          this._map.setBearing((-radians * 180) / Math.PI);
          this._suppressEvents = false;
        },

        // Called from Dart to fly to a location with animation
        flyTo: function (lat, lng, zoom) {
          if (!this._map) return;
          this._map.flyTo({
            center: [lng, lat],
            zoom: zoom || this._map.getZoom(),
            essential: true,
          });
        },

        // Called from Dart to update viewport in one call
        setViewport: function (lat, lng, zoom, radians) {
          if (!this._map) return;
          this._suppressEvents = true;
          this._map.jumpTo({
            center: [lng, lat],
            zoom: zoom,
            bearing: (-radians * 180) / Math.PI,
          });
          this._suppressEvents = false;
        },

        // ============ Boat Marker ============
        _boatMarker: null,
        _boatEl: null,

        updateBoatMarker: function (lat, lng, headingDeg) {
          if (!this._map) return;

          if (!this._boatEl) {
            this._boatEl = document.createElement('div');
            this._boatEl.innerHTML =
              '<svg width="32" height="32" viewBox="0 0 32 32">' +
              '<polygon points="16,2 26,28 16,22 6,28" ' +
              'fill="#00D9FF" fill-opacity="0.85" ' +
              'stroke="#00FFFF" stroke-width="1.5"/>' +
              '</svg>';
            this._boatEl.style.cssText =
              'width:32px;height:32px;transition:transform 0.3s ease;' +
              'filter:drop-shadow(0 0 6px #00D9FF) drop-shadow(0 0 12px #00D9FF80);';
          }

          this._boatEl.style.transform = 'rotate(' + headingDeg + 'deg)';

          if (!this._boatMarker) {
            this._boatMarker = new maplibregl.Marker({
              element: this._boatEl,
              anchor: 'center',
              rotationAlignment: 'map',
            })
              .setLngLat([lng, lat])
              .addTo(this._map);
          } else {
            this._boatMarker.setLngLat([lng, lat]);
          }
        },

        // ============ Track Line ============

        updateTrackLine: function (coords) {
          if (!this._map) return;
          var src = this._map.getSource('track-line');
          var geojson = {
            type: 'Feature',
            geometry: { type: 'LineString', coordinates: coords },
          };
          if (src) {
            src.setData(geojson);
          } else {
            this._map.addSource('track-line', {
              type: 'geojson',
              data: geojson,
            });
            this._map.addLayer({
              id: 'track-line-layer',
              type: 'line',
              source: 'track-line',
              paint: {
                'line-color': '#00D9FF',
                'line-width': 2,
                'line-opacity': 0.6,
              },
            });
          }
        },

        clearTrackLine: function () {
          if (!this._map) return;
          var src = this._map.getSource('track-line');
          if (src) {
            src.setData({
              type: 'Feature',
              geometry: { type: 'LineString', coordinates: [] },
            });
          }
        },

        // ============ Route Line & Waypoints ============
        _waypointMarkers: [],

        updateRouteLine: function (coords) {
          if (!this._map) return;
          var src = this._map.getSource('route-line');
          var geojson = {
            type: 'Feature',
            geometry: { type: 'LineString', coordinates: coords },
          };
          if (src) {
            src.setData(geojson);
          } else {
            this._map.addSource('route-line', { type: 'geojson', data: geojson });
            this._map.addLayer({
              id: 'route-line-layer',
              type: 'line',
              source: 'route-line',
              paint: {
                'line-color': '#FF00FF',
                'line-width': 3,
                'line-opacity': 0.8,
                'line-dasharray': [4, 3],
              },
            });
          }
        },

        updateWaypointMarkers: function (waypoints) {
          if (!this._map) return;
          // Remove existing markers
          this._waypointMarkers.forEach(function (m) { m.remove(); });
          this._waypointMarkers = [];
          // Create new markers
          waypoints.forEach(function (wp, i) {
            var el = document.createElement('div');
            var isLast = i === waypoints.length - 1;
            var color = isLast ? '#00FF88' : '#FF00FF';
            el.innerHTML =
              '<svg width="24" height="24" viewBox="0 0 24 24">' +
              '<circle cx="12" cy="12" r="10" fill="' + color + '" fill-opacity="0.25" ' +
              'stroke="' + color + '" stroke-width="2"/>' +
              '<text x="12" y="16" text-anchor="middle" fill="' + color + '" ' +
              'font-size="11" font-weight="bold" font-family="sans-serif">' +
              (i + 1) + '</text></svg>';
            el.style.cssText = 'width:24px;height:24px;cursor:pointer;' +
              'filter:drop-shadow(0 0 4px ' + color + '80);';
            el.title = wp.name || 'WP ' + (i + 1);
            var marker = new maplibregl.Marker({ element: el, anchor: 'center' })
              .setLngLat([wp.lng, wp.lat])
              .addTo(window.mapBridge._map);
            window.mapBridge._waypointMarkers.push(marker);
          });
        },

        clearRoute: function () {
          if (!this._map) return;
          var src = this._map.getSource('route-line');
          if (src) {
            src.setData({ type: 'Feature', geometry: { type: 'LineString', coordinates: [] } });
          }
          this._waypointMarkers.forEach(function (m) { m.remove(); });
          this._waypointMarkers = [];
        },

        // ============ WebGL Wind Particles ============
        _windEngine: null,
        _windVisible: false,
        _waveVisible: false,
        _waveCanvas: null,
        _waveCtx: null,
        _waveData: null,
        _waveAnimFrame: null,
        _waveTime: 0,

        toggleWindLayer: function (visible) {
          this._windVisible = visible;
          if (this._windEngine) {
            if (visible) {
              this._map.triggerRepaint();
            }
          }
        },

        // Accept pre-rendered wind texture as base64 PNG (from Dart/Marsal)
        setWindTexture: function (base64Png, uMin, uMax, vMin, vMax) {
          if (!this._map) return;
          var self = this;
          var img = new Image();
          img.onload = function () {
            var windData = {
              image: img,
              width: img.width,
              height: img.height,
              uMin: uMin, uMax: uMax,
              vMin: vMin, vMax: vMax,
            };
            if (!self._windEngine) {
              self._initWindEngine(windData);
            } else {
              self._windEngine.setWind(windData);
            }
            if (self._windVisible) self._map.triggerRepaint();
          };
          img.src = 'data:image/png;base64,' + base64Png;
        },

        // Update wind color ramp
        updateWindColors: function (colorStops) {
          // colorStops = { '0.0': '#00E676', '0.5': '#FF9800', '1.0': '#4A148C' }
          if (this._windEngine) {
            this._windEngine.colorRampTexture = this._windEngine._createColorRamp(colorStops);
          }
        },

        // Set wind layer visibility (alias for Marsal's API)
        setWindLayerVisible: function (visible) {
          this.toggleWindLayer(visible);
        },

        // Set wave layer visibility (alias for Marsal's API)
        setWaveLayerVisible: function (visible) {
          this.toggleWaveLayer(visible);
        },

        toggleWaveLayer: function (visible) {
          this._waveVisible = visible;
          if (this._waveCanvas) {
            this._waveCanvas.style.display = visible ? 'block' : 'none';
            if (visible) this._animateWaves();
          }
        },

        // Accept sparse wind data points and build a UV wind texture
        setWindData: function (data) {
          if (!this._map) return;
          // data = { points: [{lat, lng, u, v}], bounds: {s,n,w,e}, uMin, uMax, vMin, vMax }
          var width = 64, height = 64;
          var pixels = new Uint8Array(width * height * 4);
          var b = data.bounds;
          var uRange = data.uMax - data.uMin || 1;
          var vRange = data.vMax - data.vMin || 1;

          // Build grid with IDW interpolation from sparse points
          for (var y = 0; y < height; y++) {
            for (var x = 0; x < width; x++) {
              var lng = b.w + (x / (width - 1)) * (b.e - b.w);
              var lat = b.n - (y / (height - 1)) * (b.n - b.s);
              var uSum = 0, vSum = 0, wSum = 0;
              for (var i = 0; i < data.points.length; i++) {
                var p = data.points[i];
                var dx = lng - p.lng;
                var dy = lat - p.lat;
                var d2 = dx * dx + dy * dy;
                if (d2 < 0.0001) { uSum = p.u; vSum = p.v; wSum = 1; break; }
                var w = 1.0 / (d2 * d2); // IDW power=4
                uSum += p.u * w;
                vSum += p.v * w;
                wSum += w;
              }
              var u = wSum > 0 ? uSum / wSum : 0;
              var v = wSum > 0 ? vSum / wSum : 0;
              var idx = (y * width + x) * 4;
              // Encode normalized [0,1] into R,G channels
              var uNorm = (u - data.uMin) / uRange;
              var vNorm = (v - data.vMin) / vRange;
              pixels[idx]     = Math.floor(uNorm * 255);
              pixels[idx + 1] = Math.floor(vNorm * 255);
              pixels[idx + 2] = 0;
              pixels[idx + 3] = 255;
            }
          }

          // Create wind image data
          var windData = {
            image: pixels,
            width: width,
            height: height,
            uMin: data.uMin,
            uMax: data.uMax,
            vMin: data.vMin,
            vMax: data.vMax,
          };

          if (!this._windEngine) {
            this._initWindEngine(windData);
          } else {
            this._windEngine.setWind(windData);
          }
        },

        _initWindEngine: function (windData) {
          var self = this;
          var windLayer = {
            id: 'wind-particles',
            type: 'custom',
            renderingMode: '2d',
            onAdd: function (map, gl) {
              self._windEngine = new WindGL(gl);
              self._windEngine.numParticles = 65536;
              self._windEngine.setWind(windData);
            },
            render: function (gl, matrix) {
              if (!self._windVisible || !self._windEngine) return;
              self._windEngine.draw();
              self._map.triggerRepaint();
            },
          };
          this._map.addLayer(windLayer);
        },

        // Accept sparse wave data and render heatmap + ripple animation
        setWaveData: function (data) {
          if (!this._map) return;
          // data = { points: [{lat, lng, height, dir}], bounds: {s,n,w,e} }
          this._waveData = data;
          if (!this._waveCanvas) {
            this._initWaveCanvas();
          }
          if (this._waveVisible) {
            this._animateWaves();
          }
        },

        _initWaveCanvas: function () {
          var canvas = document.createElement('canvas');
          canvas.id = 'wave-overlay';
          canvas.style.cssText =
            'position:absolute;inset:0;width:100%;height:100%;' +
            'pointer-events:none;z-index:5;mix-blend-mode:screen;';
          document.getElementById('map').parentElement.appendChild(canvas);
          this._waveCanvas = canvas;
          this._waveCtx = canvas.getContext('2d');
        },

        _animateWaves: function () {
          var self = this;
          if (this._waveAnimFrame) cancelAnimationFrame(this._waveAnimFrame);

          function frame() {
            if (!self._waveVisible || !self._waveData) return;
            self._renderWaveFrame();
            self._waveTime += 0.02;
            self._waveAnimFrame = requestAnimationFrame(frame);
          }
          frame();
        },

        _renderWaveFrame: function () {
          var canvas = this._waveCanvas;
          var ctx = this._waveCtx;
          var data = this._waveData;
          if (!canvas || !ctx || !data || !this._map) return;

          canvas.width = canvas.clientWidth * window.devicePixelRatio;
          canvas.height = canvas.clientHeight * window.devicePixelRatio;
          ctx.setTransform(window.devicePixelRatio, 0, 0, window.devicePixelRatio, 0, 0);
          ctx.clearRect(0, 0, canvas.clientWidth, canvas.clientHeight);

          var map = this._map;
          var t = this._waveTime;
          var w = canvas.clientWidth;
          var h = canvas.clientHeight;

          // Wave color scale: height → color
          function waveColor(hm) {
            if (hm < 0.5) return [0, 229, 255, 0.35]; // cyan
            if (hm < 1.0) return [0, 200, 200, 0.40];
            if (hm < 2.0) return [255, 235, 59, 0.45]; // yellow
            if (hm < 4.0) return [255, 152, 0, 0.50];  // orange
            return [244, 67, 54, 0.55]; // red
          }

          // IDW heatmap at low res then draw
          var step = 6;
          for (var py = 0; py < h; py += step) {
            for (var px = 0; px < w; px += step) {
              var lngLat = map.unproject([px, py]);
              var hSum = 0, wSum = 0;
              for (var i = 0; i < data.points.length; i++) {
                var p = data.points[i];
                var dx = lngLat.lng - p.lng;
                var dy = lngLat.lat - p.lat;
                var d2 = dx * dx + dy * dy;
                if (d2 < 0.0001) { hSum = p.height; wSum = 1; break; }
                var wi = 1.0 / (d2 * d2);
                hSum += p.height * wi;
                wSum += wi;
              }
              var hVal = wSum > 0 ? hSum / wSum : 0;
              if (hVal < 0.1) continue;
              var c = waveColor(hVal);
              ctx.fillStyle = 'rgba(' + c[0] + ',' + c[1] + ',' + c[2] + ',' + c[3] + ')';
              ctx.fillRect(px, py, step, step);
            }
          }

          // Animated ripple rings at data points with height > 1m
          for (var j = 0; j < data.points.length; j++) {
            var pt = data.points[j];
            if (pt.height < 1.0) continue;
            var proj = map.project([pt.lng, pt.lat]);
            if (proj.x < -50 || proj.x > w + 50 || proj.y < -50 || proj.y > h + 50) continue;
            var maxR = 15 + pt.height * 5;
            for (var ring = 0; ring < 3; ring++) {
              var phase = (t + ring * 0.33) % 1.0;
              var r = phase * maxR;
              var alpha = (1.0 - phase) * 0.4;
              ctx.beginPath();
              ctx.arc(proj.x, proj.y, r, 0, Math.PI * 2);
              ctx.strokeStyle = 'rgba(0,229,255,' + alpha + ')';
              ctx.lineWidth = 1.5;
              ctx.stroke();
            }
          }
        },
      };

      // ============ WebGL Wind Particle Engine ============
      // Adapted from mapbox/webgl-wind (BSD-3-Clause)
      // GPU-accelerated wind particle system with GLSL shaders

      function WindGL(gl) {
        this.gl = gl;
        this.fadeOpacity = 0.993;
        this.speedFactor = 0.3;
        this.dropRate = 0.003;
        this.dropRateBump = 0.01;

        // Color ramp: marine theme (cyan → green → yellow → orange → magenta → purple)
        this.colorRampTexture = this._createColorRamp({
          0.0:  '#00E676',
          0.15: '#76FF03',
          0.3:  '#FFEB3B',
          0.45: '#FFC107',
          0.6:  '#FF9800',
          0.75: '#F44336',
          0.9:  '#9C27B0',
          1.0:  '#4A148C'
        });

        this.drawProgram = this._createProgram(
          // draw.vert
          'precision mediump float;' +
          'attribute float a_index;' +
          'uniform sampler2D u_particles;' +
          'uniform float u_particles_res;' +
          'varying vec2 v_particle_pos;' +
          'void main(){' +
          '  vec4 c=texture2D(u_particles,vec2(fract(a_index/u_particles_res),floor(a_index/u_particles_res)/u_particles_res));' +
          '  v_particle_pos=vec2(c.r/255.0+c.b,c.g/255.0+c.a);' +
          '  gl_PointSize=1.0;' +
          '  gl_Position=vec4(2.0*v_particle_pos.x-1.0,1.0-2.0*v_particle_pos.y,0,1);' +
          '}',
          // draw.frag
          'precision mediump float;' +
          'uniform sampler2D u_wind;' +
          'uniform vec2 u_wind_min;' +
          'uniform vec2 u_wind_max;' +
          'uniform sampler2D u_color_ramp;' +
          'varying vec2 v_particle_pos;' +
          'void main(){' +
          '  vec2 v=mix(u_wind_min,u_wind_max,texture2D(u_wind,v_particle_pos).rg);' +
          '  float s=length(v)/length(u_wind_max);' +
          '  vec2 rp=vec2(fract(16.0*s),floor(16.0*s)/16.0);' +
          '  gl_FragColor=texture2D(u_color_ramp,rp);' +
          '}'
        );

        this.screenProgram = this._createProgram(
          // quad.vert
          'precision mediump float;' +
          'attribute vec2 a_pos;' +
          'varying vec2 v_tex_pos;' +
          'void main(){v_tex_pos=a_pos;gl_Position=vec4(1.0-2.0*a_pos,0,1);}',
          // screen.frag
          'precision mediump float;' +
          'uniform sampler2D u_screen;' +
          'uniform float u_opacity;' +
          'varying vec2 v_tex_pos;' +
          'void main(){' +
          '  vec4 c=texture2D(u_screen,1.0-v_tex_pos);' +
          '  gl_FragColor=vec4(floor(255.0*c*u_opacity)/255.0);' +
          '}'
        );

        this.updateProgram = this._createProgram(
          // quad.vert (reuse)
          'precision mediump float;' +
          'attribute vec2 a_pos;' +
          'varying vec2 v_tex_pos;' +
          'void main(){v_tex_pos=a_pos;gl_Position=vec4(1.0-2.0*a_pos,0,1);}',
          // update.frag
          'precision highp float;' +
          'uniform sampler2D u_particles;' +
          'uniform sampler2D u_wind;' +
          'uniform vec2 u_wind_res;' +
          'uniform vec2 u_wind_min;' +
          'uniform vec2 u_wind_max;' +
          'uniform float u_rand_seed;' +
          'uniform float u_speed_factor;' +
          'uniform float u_drop_rate;' +
          'uniform float u_drop_rate_bump;' +
          'varying vec2 v_tex_pos;' +
          'const vec3 rc=vec3(12.9898,78.233,4375.85453);' +
          'float rand(const vec2 co){float t=dot(rc.xy,co);return fract(sin(t)*(rc.z+t));}' +
          'vec2 lookup_wind(const vec2 uv){' +
          '  vec2 px=1.0/u_wind_res;' +
          '  vec2 vc=floor(uv*u_wind_res)*px;' +
          '  vec2 f=fract(uv*u_wind_res);' +
          '  vec2 tl=texture2D(u_wind,vc).rg;' +
          '  vec2 tr=texture2D(u_wind,vc+vec2(px.x,0)).rg;' +
          '  vec2 bl=texture2D(u_wind,vc+vec2(0,px.y)).rg;' +
          '  vec2 br=texture2D(u_wind,vc+px).rg;' +
          '  return mix(mix(tl,tr,f.x),mix(bl,br,f.x),f.y);' +
          '}' +
          'void main(){' +
          '  vec4 c=texture2D(u_particles,v_tex_pos);' +
          '  vec2 pos=vec2(c.r/255.0+c.b,c.g/255.0+c.a);' +
          '  vec2 v=mix(u_wind_min,u_wind_max,lookup_wind(pos));' +
          '  float st=length(v)/length(u_wind_max);' +
          '  float dist=cos(radians(pos.y*180.0-90.0));' +
          '  vec2 off=vec2(v.x/dist,-v.y)*0.0001*u_speed_factor;' +
          '  pos=fract(1.0+pos+off);' +
          '  vec2 seed=(pos+v_tex_pos)*u_rand_seed;' +
          '  float dr=u_drop_rate+st*u_drop_rate_bump;' +
          '  float drop=step(1.0-dr,rand(seed));' +
          '  vec2 rpos=vec2(rand(seed+1.3),rand(seed+2.1));' +
          '  pos=mix(pos,rpos,drop);' +
          '  gl_FragColor=vec4(fract(pos*255.0),floor(pos*255.0)/255.0);' +
          '}'
        );

        this.quadBuffer = this._createBuffer(new Float32Array([0,0,1,0,0,1,0,1,1,0,1,1]));
        this.framebuffer = gl.createFramebuffer();
        this._resize();
      }

      WindGL.prototype._resize = function () {
        var gl = this.gl;
        var empty = new Uint8Array(gl.canvas.width * gl.canvas.height * 4);
        this.backgroundTexture = this._createTexture(gl.NEAREST, empty, gl.canvas.width, gl.canvas.height);
        this.screenTexture = this._createTexture(gl.NEAREST, empty, gl.canvas.width, gl.canvas.height);
      };

      WindGL.prototype.setWind = function (windData) {
        this.windData = windData;
        this.windTexture = this._createTexture(this.gl.LINEAR, windData.image, windData.width, windData.height);
      };

      WindGL.prototype.draw = function () {
        var gl = this.gl;
        gl.disable(gl.DEPTH_TEST);
        gl.disable(gl.STENCIL_TEST);
        this._bindTexture(this.windTexture, 0);
        this._bindTexture(this.particleStateTexture0, 1);
        this._drawScreen();
        this._updateParticles();
      };

      WindGL.prototype._drawScreen = function () {
        var gl = this.gl;
        this._bindFramebuffer(this.framebuffer, this.screenTexture);
        gl.viewport(0, 0, gl.canvas.width, gl.canvas.height);
        this._drawTexture(this.backgroundTexture, this.fadeOpacity);
        this._drawParticles();
        this._bindFramebuffer(null);
        gl.enable(gl.BLEND);
        gl.blendFunc(gl.SRC_ALPHA, gl.ONE_MINUS_SRC_ALPHA);
        this._drawTexture(this.screenTexture, 1.0);
        gl.disable(gl.BLEND);
        var tmp = this.backgroundTexture;
        this.backgroundTexture = this.screenTexture;
        this.screenTexture = tmp;
      };

      WindGL.prototype._drawTexture = function (texture, opacity) {
        var gl = this.gl;
        var p = this.screenProgram;
        gl.useProgram(p.program);
        this._bindAttribute(this.quadBuffer, p.a_pos, 2);
        this._bindTexture(texture, 2);
        gl.uniform1i(p.u_screen, 2);
        gl.uniform1f(p.u_opacity, opacity);
        gl.drawArrays(gl.TRIANGLES, 0, 6);
      };

      WindGL.prototype._drawParticles = function () {
        var gl = this.gl;
        var p = this.drawProgram;
        gl.useProgram(p.program);
        this._bindAttribute(this.particleIndexBuffer, p.a_index, 1);
        this._bindTexture(this.colorRampTexture, 2);
        gl.uniform1i(p.u_wind, 0);
        gl.uniform1i(p.u_particles, 1);
        gl.uniform1i(p.u_color_ramp, 2);
        gl.uniform1f(p.u_particles_res, this.particleStateResolution);
        gl.uniform2f(p.u_wind_min, this.windData.uMin, this.windData.vMin);
        gl.uniform2f(p.u_wind_max, this.windData.uMax, this.windData.vMax);
        gl.drawArrays(gl.POINTS, 0, this._numParticles);
      };

      WindGL.prototype._updateParticles = function () {
        var gl = this.gl;
        this._bindFramebuffer(this.framebuffer, this.particleStateTexture1);
        gl.viewport(0, 0, this.particleStateResolution, this.particleStateResolution);
        var p = this.updateProgram;
        gl.useProgram(p.program);
        this._bindAttribute(this.quadBuffer, p.a_pos, 2);
        gl.uniform1i(p.u_wind, 0);
        gl.uniform1i(p.u_particles, 1);
        gl.uniform1f(p.u_rand_seed, Math.random());
        gl.uniform2f(p.u_wind_res, this.windData.width, this.windData.height);
        gl.uniform2f(p.u_wind_min, this.windData.uMin, this.windData.vMin);
        gl.uniform2f(p.u_wind_max, this.windData.uMax, this.windData.vMax);
        gl.uniform1f(p.u_speed_factor, this.speedFactor);
        gl.uniform1f(p.u_drop_rate, this.dropRate);
        gl.uniform1f(p.u_drop_rate_bump, this.dropRateBump);
        gl.drawArrays(gl.TRIANGLES, 0, 6);
        var tmp = this.particleStateTexture0;
        this.particleStateTexture0 = this.particleStateTexture1;
        this.particleStateTexture1 = tmp;
      };

      // Set particle count (creates state textures)
      WindGL.prototype.set_numParticles = function (n) {
        var gl = this.gl;
        var res = this.particleStateResolution = Math.ceil(Math.sqrt(n));
        this._numParticles = res * res;
        var state = new Uint8Array(this._numParticles * 4);
        for (var i = 0; i < state.length; i++) state[i] = Math.floor(Math.random() * 256);
        this.particleStateTexture0 = this._createTexture(gl.NEAREST, state, res, res);
        this.particleStateTexture1 = this._createTexture(gl.NEAREST, state, res, res);
        var indices = new Float32Array(this._numParticles);
        for (var j = 0; j < this._numParticles; j++) indices[j] = j;
        this.particleIndexBuffer = this._createBuffer(indices);
      };
      Object.defineProperty(WindGL.prototype, 'numParticles', {
        set: WindGL.prototype.set_numParticles,
        get: function () { return this._numParticles; }
      });

      // WebGL utility methods
      WindGL.prototype._createShader = function (type, source) {
        var gl = this.gl;
        var s = gl.createShader(type);
        gl.shaderSource(s, source);
        gl.compileShader(s);
        if (!gl.getShaderParameter(s, gl.COMPILE_STATUS))
          console.error('Shader error:', gl.getShaderInfoLog(s));
        return s;
      };

      WindGL.prototype._createProgram = function (vert, frag) {
        var gl = this.gl;
        var prog = gl.createProgram();
        gl.attachShader(prog, this._createShader(gl.VERTEX_SHADER, vert));
        gl.attachShader(prog, this._createShader(gl.FRAGMENT_SHADER, frag));
        gl.linkProgram(prog);
        if (!gl.getProgramParameter(prog, gl.LINK_STATUS))
          console.error('Program error:', gl.getProgramInfoLog(prog));
        var w = { program: prog };
        var na = gl.getProgramParameter(prog, gl.ACTIVE_ATTRIBUTES);
        for (var i = 0; i < na; i++) {
          var a = gl.getActiveAttrib(prog, i);
          w[a.name] = gl.getAttribLocation(prog, a.name);
        }
        var nu = gl.getProgramParameter(prog, gl.ACTIVE_UNIFORMS);
        for (var j = 0; j < nu; j++) {
          var u = gl.getActiveUniform(prog, j);
          w[u.name] = gl.getUniformLocation(prog, u.name);
        }
        return w;
      };

      WindGL.prototype._createTexture = function (filter, data, width, height) {
        var gl = this.gl;
        var tex = gl.createTexture();
        gl.bindTexture(gl.TEXTURE_2D, tex);
        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);
        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, filter);
        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, filter);
        if (data instanceof Uint8Array) {
          gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, width, height, 0, gl.RGBA, gl.UNSIGNED_BYTE, data);
        } else {
          // HTMLImageElement or HTMLCanvasElement
          gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, gl.RGBA, gl.UNSIGNED_BYTE, data);
        }
        gl.bindTexture(gl.TEXTURE_2D, null);
        return tex;
      };

      WindGL.prototype._createBuffer = function (data) {
        var gl = this.gl;
        var buf = gl.createBuffer();
        gl.bindBuffer(gl.ARRAY_BUFFER, buf);
        gl.bufferData(gl.ARRAY_BUFFER, data, gl.STATIC_DRAW);
        return buf;
      };

      WindGL.prototype._bindTexture = function (tex, unit) {
        var gl = this.gl;
        gl.activeTexture(gl.TEXTURE0 + unit);
        gl.bindTexture(gl.TEXTURE_2D, tex);
      };

      WindGL.prototype._bindAttribute = function (buf, attr, n) {
        var gl = this.gl;
        gl.bindBuffer(gl.ARRAY_BUFFER, buf);
        gl.enableVertexAttribArray(attr);
        gl.vertexAttribPointer(attr, n, gl.FLOAT, false, 0, 0);
      };

      WindGL.prototype._bindFramebuffer = function (fb, tex) {
        var gl = this.gl;
        gl.bindFramebuffer(gl.FRAMEBUFFER, fb);
        if (tex) gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0, gl.TEXTURE_2D, tex, 0);
      };

      WindGL.prototype._createColorRamp = function (colors) {
        var canvas = document.createElement('canvas');
        canvas.width = 256; canvas.height = 1;
        var ctx = canvas.getContext('2d');
        var grad = ctx.createLinearGradient(0, 0, 256, 0);
        for (var stop in colors) grad.addColorStop(+stop, colors[stop]);
        ctx.fillStyle = grad;
        ctx.fillRect(0, 0, 256, 1);
        var data = new Uint8Array(ctx.getImageData(0, 0, 256, 1).data);
        return this._createTexture(this.gl.LINEAR, data, 16, 16);
      };
    </script>
  </body>
</html>
